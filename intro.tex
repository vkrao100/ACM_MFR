\section{Introduction}
Debugging and rectification of digital logic circuits aims to correct
a given defective circuit implementation to match its intended
specification. The process constitutes identifying
candidate nets in the circuit as targets for rectification, followed by  
a check to determine whether the circuit can be patched at these
targets. If the targets admit correction, corresponding rectification
functions are computed and synthesized to fix the circuit at these targets.
%Begin ACM journal
{\red  
It is akin to performing synthesis for Engineering Change Order 
(ECO), wherein a highly optimized implementation is minimally modified to match the 
updated specification in a cost effective way. This is achieved by reusing prior design 
efforts and avoiding rerunning the entire synthesis flow, while adhering to the resource 
constraints and the physical design limitations.

The rectification problem has witnessed a lot of research over the years -- 
some of the earliest being~\cite{Sadowska:DAC95,scholl:1,andreas:2005}.
Owing to a manifold improvement in the efficiency of SAT solvers,
there has been a renewed interest in the problem over the last decade from 
the logic synthesis, testing and verification communities~\cite{
MF_Huang:DATE12,scholl:2,SS_Fujita:ISQED17,SS_Alan:DAC18}.
These techniques generally employ SAT, Quantified Boolean Formula (QBF) solving,
and Craig Interpolation (CI) based techniques for rectification. While
successful for control-dominated applications, these techniques are
computationally infeasible for rectification of arithmetic circuits.
Symbolic Computer Algebra (SCA) techniques are found to be more
suitable for formal analysis and verification of arithmetic circuits.
However, utilization of the various facets and capabilities of the SCA
techniques for post-verification debugging and rectification has only
recently begun to be addressed
\cite{farimah:2017:1,MF_Rolf:ISVLSI18,Utkarsh:VLSI18,
Vkrao:FMCAD18,Vkrao:ISQED21,Vkrao:GLSVLSI21}. }
%End ACM journal

This paper addresses the problem of {\it rectification
  of faulty finite field arithmetic circuits} at a given set of $m$
targets. Rectification is performed against a 
given polynomial specification over finite
fields using SCA and algebraic geometry based techniques. 
Such circuits find application in cryptography and error-control codes. 
%Begin ACM journal
{\red As arithmetic bugs may lead to security
vulnerabilities in crypto-systems \cite{crypto:bug_attacks}, their
rectification is of utmost importance. 
%End ACM journal
Our approach, derives the necessary and sufficient conditions
for the existence of a rectification function, computes rectification patches
as polynomials for the given targets, and synthesizes them into logic sub-circuits.}

%While successful for control-dominated applications, the SAT-based 
%models~[4-10] however are infeasible for rectification of arithmetic circuits. 

{\it Problem Statement and Objective:}
We are given the following: i) as the specification, a multivariate
polynomial $f$ with coefficients in a finite field of $2^n$ elements
(denoted $\F_{2^n}$), for a given  $n\in \Z_{> 0}$; ii) an irreducible
polynomial $P_n(x)$ of degree $n$ with coefficients in $\{0,1\}$ used 
to construct $\Fkn$; iii) a faulty circuit implementation $C$,
with no assumptions on the number or the type of bugs present in
$C$; and iv) a set $W = (w_1,\dots,w_m)$ of $m$ targets from $C$,
pre-specified or selected using contemporary signal selection heuristics 
~\cite{SS_Alan:DAC18,SS_Fujita:ISCAS19,SS_Roland:DAC19}.
% We further assume that it has been ascertained that $C$ 
% admits rectification at these $m$ targets, using~\cite{MF_Huang:DATE12,Vkrao:ISQED21}. 
The objective of our approach is to: 
{\red i) ascertain that $C$ 
admits rectification at these $m$ targets}
ii) compute a set
of individual rectification functions $U =
(u_1,\dots,u_m)$ for the corresponding targets. Here, each $u_i$ is a 
polynomial function $u_i:\F_2^{|X_{PI}|}\rightarrow\F_2$, where $\F_2=\{0,1\}$, 
and $X_{PI}$ denotes the
set of primary inputs; iii) derive {\it don't care conditions}
corresponding to the $m$ rectification functions; and iv) synthesize
the rectification polynomials into logic sub-circuit patches.
%Note that the cardinality of $|W|=|U|=|O|=m$.


{\it Prior Work:} Contemporary approaches formulate rectification
using QBF solving~\cite{scholl:2}, using CI or iterative SAT
solving~\cite{MF_Huang:DATE12}.  
The rectification techniques in 
\cite{SS_Fujita:ISCAS19,MF_Huang:DATE12,SS_Roland:DAC18} 
iteratively and incrementally compute multiple single-fix functions
that partially patch the circuit in each iteration.
{\red They ensure that, in each iteration, erroneous minterms are resolved
and no new errors are introduced, eventually converging the circuit
to the given specification.}
The more recent techniques further
include more resource awareness in patch generation by reusing
existing logic \cite{SS_Alan:DAC18}, employ improved heuristics for
target selection \cite{SS_Fujita:ISCAS19}.
% , or resolve a combination of
% such objectives, such as the symbolic sampling approach of
% \cite{SS_Roland:DAC19}.
{\red A robust ECO approach to derive patches with minimal 
impact on the heavily optimized existing implementation against 
a structurally dissimilar ECO-evolved specification has been presented in
\cite{SS_Roland:DAC19}. 
The authors~\cite{SS_Roland:DAC19} propose enumerating rectification points 
functionally by simulation and match the circuitry of patches implicitly to maximize reuse of 
existing logic in the implementation. To achieve scalability, the method proposes 
modeling and analyzing its computations in symbolic sampling domain. }
While successful for control-dominated applications, these techniques are
computationally infeasible for rectification of arithmetic circuits.

In the context of arithmetic circuits, symbolic computer algebra 
techniques for integer arithmetic~\cite{farimah:2017:1,MF_Rolf:ISVLSI18} and
finite field circuits~\cite{Utkarsh:ETS19,Utkarsh:VLSI18,Vkrao:FMCAD18}
have been considered for rectification. However, these algebraic
approaches address only {\it single-fix rectification} -- where
irrespective of the type or number of bugs in the circuit,
rectification is attempted at a single net. This is too restrictive
and depending on the nature of the bugs, the circuit may not admit
single-fix rectification at all. In such cases, correction has to be
attempted at multiple targets.
Recently,~\cite{Vkrao:ISQED21} proposes an SCA based approach to 
{\it decide $m$-target rectifiability}. Given a set of $m$-targets,
the approach can only ascertain whether {\it there exists} a set of
patch functions that can patch the circuit at those targets. As 
it is only a decision procedure, the proposed approach cannot 
{\it compute} rectification functions.
Thus the problem of multi-fix rectification of data-path circuits
remains unsolved, and theoretical and algorithmic solutions to compute
and synthesize rectification patches for arithmetic circuits are still
desired. 

{\red 

}

{\it Approach and Contribution:}
% In particular, we exploit the ideal-variety
% correspondences to explore and compute rectification functions for the $m$-targets
% collectively. 
The specification and implementation are modeled in terms of polynomial ideals, and
the rectification functions are computed using the \Grobner bases of these ideals~\cite{gb_book}.
We model this computation as a quantification procedure by utilizing
concepts from computer algebra and algebraic geometry. 
In this regard, our approach goes beyond
the Nullstellensatz-based results produced from the $m$-target
rectifiability check presented in~\cite{Vkrao:ISQED21}, and {\it computes}
$m$ individual rectification functions altogether. This allows us to
efficiently explore the space of various admissible rectification
functions, in turn, computing subsets of don't care conditions
which help in simplifying the rectification patches. Synthesis of the 
corresponding polynomial patch functions, along with don't cares,  
demonstrates the efficacy of our approach in terms of improved area 
and delay characteristics of the patches.
Overall, the  the computation of rectification functions at multiple
targets, and modeling don't cares for MFR in
polynomial algebra, are our novel contributions not presented
in prior literature. 

%While these are computed as
%polynomial ideals, the functions and don't care conditions correspond
%to their algebraic varieties, and so the polynomials
% We transform the given circuit implementation 
% into a system of polynomials and compute the relevant \Grobner basis 
% (GB)~\cite{gb_book} ideals from these polynomials. Subsequently, the rectifiability check is 
% formulated on these ideals using the Strong Nullstellensatz over finite fields and solved 
% using the GB engine. Further, 
%% We compute the individual rectification functions by 
%% utilizing the concepts of reduced \Grobner basis and ideal-variety correspondences.
%% While there may exist multiple rectification functions for each of the $m$ targets, 
%% we compute and synthesize one such individual function for each of the targets.
%% In addition, We show how in our algebraic model the ODC's
%% correspond to {\it varieties of polynomial ideals}, and how they can
%% be computed with \Grobner bases.
%% However, exploiting symbolic algebra techniques on generating low-cost patches and
%% computing a patch function in terms of internal nets needs further investigation and 
%% tuning, which is beyond the scope of this paper.


 % and modeling it as a quantification procedure.

%{\it Motivation:}

 
% However, the authors don't discuss the application of the proposed method 
% to arithmetic circuits, hence an efficient/scalable solution is still desired. 
% However, these techniques are also SAT and/or Craig-interpolation based, w 
%  Boolean function and SAT-based models are infeasible for rectification 
% of faulty arithmetic circuits

 
% {\it Approach:}
% The given $\impl$ $C$, with operand word-length $n$, is modeled
% as a polynomial ideal in the multivariate polynomial ring with
% coefficients in the finite field $\Fkn$, denoted $\Fkn[x_1,\dots,x_d]$. 
% The $m$ targets are collected as an $m$-bit-vector tuple, which evaluates in $\Ftwo$.
% For the rectification check, the %hitherto 
% unknown rectification functions ($U = \{u_0,\dots,u_m\}$) are modeled as bit-level
% polynomial functions in primary inputs (i.e. $W = U(X_{PI})$), which maps 
% $n$-bit primary inputs $X_{PI}$ to an $m$-bit word $W :\F_2^{|X_{PI}|} \rightarrow \Fkm$.
% The rectifiability check 
% is then formulated with algebraic geometry over finite fields 
% and solved using \Grobner basis (GB) techniques~\cite{gb_book}


% Our approach is implemented using the polynomial algebra computational
% engines of {\sc Singular} \cite{DGPS_410} and {\sc PolyBori}
% \cite{pbori:JSC09}.

{\red We reason about the presence or absence of solutions 
and other properties of a system of polynomials without explicitly solving them. 
In contrast, the contemporary approaches explicitly solve for a solution at 
each step and hence are infeasible towards rectification of arithmetic circuits.
We present theoretical concepts and algorithms, and their efficient implementations, 
for finite field arithmetic circuit debug and rectification. The logic corrections 
are computed as polynomial functions in primary input variables, which are synthesized 
into rectification patches for the corresponding targets. 
Our algebraic approach provides a scalable solution for rectification
of finite field arithmetic circuits.}

{\it Paper Organization:} The following section covers preliminary
background. Section~\ref{sec:pmodel} reviews the polynomial modeling
concepts. Rectification check formulation is described in
Section~\ref{sec:rcheck}, followed by the rectification function and
don't care computations in Section~\ref{sec:rfunc}. Section~\ref{impl}
discusses the implementation details, and experimental
results are described in Section \ref{sec:exp}, and
Section~\ref{sec:conc} concludes the paper. 